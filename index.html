<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebBench - CPU, GPU & RAM Benchmark</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f0f13;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: padding 0.3s ease;
        }
        .canvas-container {
            box-shadow: 0 0 30px rgba(147, 51, 234, 0.3);
            background-color: #000;
            line-height: 0;
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        canvas {
            width: 100%;
            height: auto;
            display: block;
        }
        /* バケット（CPUレンダリング中の枠） */
        .bucket {
            position: absolute;
            border: 1px solid #d946ef;
            background-color: rgba(217, 70, 239, 0.2);
            pointer-events: none;
            z-index: 10;
        }
        /* Progress Bar for RAM */
        .ram-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background-color: #10b981; /* Emerald 500 */
            width: 0%;
            transition: width 0.1s linear;
        }
        .btn-primary {
            background: linear-gradient(135deg, #9333ea 0%, #7e22ce 100%);
            transition: all 0.2s;
        }
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(147, 51, 234, 0.4);
            filter: brightness(1.1);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        /* Cancel Button Style */
        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #b91c1c 100%);
            transition: all 0.2s;
        }
        .btn-danger:hover {
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
            filter: brightness(1.1);
        }
        .score-display {
            font-variant-numeric: tabular-nums;
        }
        .badge-ludicrous {
            background-color: #9333ea;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            vertical-align: middle;
            margin-left: 8px;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(147, 51, 234, 0.5);
            white-space: nowrap;
        }
        .btn-copy {
            background-color: #374151;
            transition: all 0.2s;
        }
        .btn-copy:hover {
            background-color: #4b5563;
        }
        .cpu-input, .mode-select {
            background-color: rgba(31, 41, 55, 0.5);
            border: 1px solid rgba(75, 85, 99, 0.5);
            color: #d1d5db;
            transition: all 0.2s;
        }
        .cpu-input:focus, .mode-select:focus {
            outline: none;
            border-color: #9333ea;
            background-color: rgba(31, 41, 55, 0.8);
        }
        
        /* Mode selection specific styles */
        /* GPU Mode (Blue) */
        .mode-gpu .text-purple-400 { color: #3b82f6; } 
        .mode-gpu .border-purple-900\/50 { border-color: rgba(30, 58, 138, 0.5); }
        .mode-gpu .btn-primary { background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%); }
        .mode-gpu .badge-ludicrous { background-color: #2563eb; box-shadow: 0 0 10px rgba(37, 99, 235, 0.5); }
        .mode-gpu .canvas-container { box-shadow: 0 0 30px rgba(37, 99, 235, 0.3); }

        /* RAM Mode (Green) */
        .mode-ram .text-purple-400 { color: #10b981; } 
        .mode-ram .border-purple-900\/50 { border-color: rgba(6, 78, 59, 0.5); }
        .mode-ram .btn-primary { background: linear-gradient(135deg, #10b981 0%, #047857 100%); }
        .mode-ram .badge-ludicrous { background-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.5); }
        .mode-ram .canvas-container { box-shadow: 0 0 30px rgba(16, 185, 129, 0.3); }
        
        /* RAM Visualizer in Canvas */
        .ram-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(20px, 1fr));
            width: 100%;
            height: 100%;
            padding: 20px;
            gap: 2px;
        }
        .ram-cell {
            background-color: #064e3b;
            transition: background-color 0.1s;
        }
        .ram-cell.active {
            background-color: #34d399;
            box-shadow: 0 0 5px #34d399;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-3 sm:p-6 md:p-8" id="body-app">

    <!-- Header -->
    <div class="w-full max-w-7xl flex flex-col sm:flex-row justify-between items-start sm:items-end mb-4 sm:mb-6 border-b border-purple-900/50 pb-4 gap-4 sm:gap-0 transition-all duration-300" id="header-container">
        <div>
            <h1 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-white tracking-wider transition-all duration-300">WEBBENCH <span class="text-purple-400 text-sm sm:text-base align-top" id="version-text">Hybrid</span></h1>
            <p class="text-purple-300/60 text-xs sm:text-sm mt-1">Browser-based Hardware Stress Test <span class="badge-ludicrous" id="load-badge">HEAVY LOAD</span></p>
        </div>
        <div class="text-right flex flex-col items-end gap-1 w-full sm:w-auto">
            <div class="text-purple-300/60 text-xs sm:text-sm">System Info</div>
            <div class="text-xl sm:text-2xl font-bold text-white leading-none transition-all duration-300" id="core-count">--</div>
            <!-- CPU Name Input Field -->
            <input type="text" id="cpu-name-input" class="cpu-input text-xs sm:text-sm px-3 py-1 rounded text-right w-full sm:w-56 mt-1" placeholder="Enter Device Name">
        </div>
    </div>

    <!-- Main Content -->
    <div class="w-full max-w-7xl grid grid-cols-1 lg:grid-cols-4 gap-6 lg:gap-8 transition-all duration-300">
        
        <!-- Controls & Results (Left Panel) -->
        <div class="lg:col-span-1 flex flex-col gap-4 order-2 lg:order-1">
            <div class="bg-gray-900/80 p-4 sm:p-5 rounded-lg border border-purple-900/50 shadow-lg" id="control-panel">
                <h2 class="text-xs sm:text-sm font-bold text-purple-400 mb-3 uppercase tracking-wide">Configuration</h2>
                
                <!-- Mode Selector -->
                <div class="mb-4">
                    <label class="block text-xs text-gray-400 mb-1">Benchmark Mode</label>
                    <select id="mode-select" class="mode-select w-full text-white text-sm py-2 px-3 rounded">
                        <option value="cpu">CPU (Raytracing)</option>
                        <option value="gpu">GPU (WebGL Fractal)</option>
                        <option value="ram">Memory (RAM Speed)</option>
                    </select>
                </div>

                <!-- Duration Selector -->
                <div class="mb-4">
                    <label class="block text-xs text-gray-400 mb-1">Test Duration</label>
                    <select id="duration-select" class="mode-select w-full text-white text-sm py-2 px-3 rounded">
                        <option value="default">Standard (Default)</option>
                        <option value="60000">1 Minute (Stress Test)</option>
                        <option value="180000">3 Minutes (Stress Test)</option>
                        <option value="300000">5 Minutes (Stress Test)</option>
                        <option value="600000">10 Minutes (Stability Test)</option>
                    </select>
                </div>

                <button id="start-btn" class="btn-primary w-full text-white font-bold py-3 sm:py-4 px-6 rounded-md shadow-lg mb-3 text-base sm:text-lg transition-all duration-300">
                    RUN BENCHMARK
                </button>
                <div id="status-text" class="text-xs sm:text-sm text-center text-purple-300 h-6 mb-2">Ready</div>
                
                <!-- Share Area (Hidden initially) -->
                <div id="share-area" class="hidden border-t border-gray-700 pt-4 mt-2 flex flex-col gap-2">
                    <button id="copy-btn" class="btn-copy w-full text-white font-bold py-3 px-4 rounded-md text-xs sm:text-sm">
                        Copy Result
                    </button>
                </div>
            </div>

            <div class="bg-gray-900/80 p-4 sm:p-5 rounded-lg border border-purple-900/50 flex-grow flex flex-col shadow-lg" id="score-panel">
                <h2 class="text-xs sm:text-sm font-bold text-purple-400 mb-4 uppercase tracking-wide">Scores</h2>
                
                <div class="space-y-3 sm:space-y-4 text-xs sm:text-sm" id="score-list">
                    <!-- Scores injected via JS -->
                </div>
                
                <div class="mt-4 sm:mt-6 text-[10px] sm:text-xs text-gray-500 text-center border-t border-gray-800 pt-3">
                     *Scores vary by browser/driver
                </div>
            </div>
        </div>

        <!-- Render Viewport (Right Panel) -->
        <div class="lg:col-span-3 order-1 lg:order-2">
            <div class="canvas-container rounded-lg border-2 border-purple-900/30 relative w-full aspect-video bg-black shadow-2xl" id="canvas-wrapper">
                <!-- Canvas is dynamically injected here -->
            </div>
            
            <div class="mt-3 flex justify-between text-xs sm:text-sm text-gray-500 font-mono px-1">
                <span id="resolution-info">Select Mode to Start</span>
                <span id="time-info">Time: 0.00s</span>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="mt-8 sm:mt-12 text-gray-500 text-xs sm:text-sm text-center pb-8">
        <p>Warning: This benchmark places extreme load on CPU, GPU or Memory.</p>
        <p class="text-xs opacity-50 mt-1">Heavy Mode: 1080p / 8x Samples / 140+ Objects / 5 Bounces</p>
        
        <div class="mt-6 pt-6 border-t border-gray-800/50 w-2/3 mx-auto">
            <p class="text-purple-400 font-bold mb-1">About</p>
            <p>Created by seichan</p>
        </div>
    </div>

    <!-- WORKER SCRIPT TEMPLATE (Unified) -->
    <script id="worker-code" type="javascript/worker">
        // Vector class for Raytracing
        class Vec3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
            cross(v) { return new Vec3(this.y*v.z - this.z*v.y, this.z*v.x - this.x*v.z, this.x*v.y - this.y*v.x); }
            norm() { 
                let m = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); 
                return m === 0 ? new Vec3(0,0,0) : new Vec3(this.x/m, this.y/m, this.z/m); 
            }
        }

        // --- Raytracing Logic ---
        const spheres = [];
        spheres.push({ c: new Vec3(0, 1, 0), r: 1, mat: 2, col: new Vec3(0.8, 0.8, 0.8) });
        // Heavy Mode: Reduced object count (approx 144 spheres)
        for (let x = -6; x < 6; x++) {
            for (let z = -6; z < 6; z++) {
                let r = 0.5 + 0.5 * Math.sin(x * 0.5);
                let g = 0.5 + 0.5 * Math.sin(z * 0.5);
                let b = 0.5 + 0.5 * Math.cos((x+z) * 0.3);
                let mat = ((x + z) % 5 === 0) ? 2 : 1;
                let radius = 0.2 + 0.15 * Math.sin(x*z);
                spheres.push({c: new Vec3(x * 1.0 + Math.sin(z)*0.5, radius, z * 1.0 - 2),r: radius,mat: mat,col: new Vec3(r, g, b)});
            }
        }
        const lightDir = new Vec3(0.5, 1, -0.5).norm();
        function intersectSphere(ro, rd, s) {
            let oc = ro.sub(s.c);
            let b = oc.dot(rd);
            let c = oc.dot(oc) - s.r * s.r;
            let d = b * b - c;
            if (d > 0) return -b - Math.sqrt(d);
            return Infinity;
        }
        function getBackground(rd) {
            let t = 0.5 * (rd.y + 1.0);
            return new Vec3(0.1, 0.1, 0.1).mul(1.0 - t).add(new Vec3(0.2, 0.1, 0.3).mul(t));
        }
        function trace(ro, rd, depth) {
            let t = Infinity, id = -1;
            if (rd.y < -0.001) { let tp = -ro.y / rd.y; if (tp > 0 && tp < t) { t = tp; id = -2; } }
            for (let i = 0; i < spheres.length; i++) { let ts = intersectSphere(ro, rd, spheres[i]); if (ts > 0.001 && ts < t) { t = ts; id = i; } }
            if (t === Infinity) return getBackground(rd);
            let p = ro.add(rd.mul(t));
            let n, col, isMirror = false;
            if (id === -2) {
                n = new Vec3(0, 1, 0);
                let checker = (Math.floor(p.x*2) + Math.floor(p.z*2)) % 2 === 0;
                col = checker ? new Vec3(0.15, 0.15, 0.15) : new Vec3(0.1, 0.1, 0.1);
                if (!checker) isMirror = true; 
            } else {
                let s = spheres[id]; n = p.sub(s.c).norm(); col = s.col; if (s.mat === 2) isMirror = true;
            }
            let shadow = 1.0;
            let shadowRayOrigin = p.add(n.mul(0.001));
            for (let i = 0; i < spheres.length; i++) { if (id !== i) { if (intersectSphere(shadowRayOrigin, lightDir, spheres[i]) < Infinity) { shadow = 0.1; break; } } }
            let diff = Math.max(0, n.dot(lightDir));
            let finalCol = col.mul(diff * shadow + 0.05);
            // Heavy Mode: Reduced Depth to 5
            if (isMirror && depth < 5) {
                let reflectDir = rd.sub(n.mul(2 * rd.dot(n))).norm();
                let reflectCol = trace(p.add(n.mul(0.001)), reflectDir, depth + 1);
                finalCol = finalCol.mul(0.2).add(reflectCol.mul(0.8));
            }
            return finalCol;
        }

        // --- Main Handler ---
        self.onmessage = function(e) {
            if (e.data.taskType === 'ram') {
                // RAM BENCHMARK
                const size = 32 * 1024 * 1024; // 32MB per chunk per pass
                const arr = new Uint32Array(size / 4);
                
                const t0 = performance.now();
                // Write Pass
                for(let i=0; i<arr.length; i++) {
                    arr[i] = i ^ 0xDEADBEEF;
                }
                // Read/Check Pass
                let sum = 0;
                for(let i=0; i<arr.length; i++) {
                    sum += arr[i];
                }
                const t1 = performance.now();
                
                self.postMessage({ 
                    taskType: 'ram', 
                    workerId: e.data.workerId, 
                    bytesProcessed: size * 2, 
                    duration: t1 - t0,
                    check: sum
                });

            } else {
                // RAYTRACING BENCHMARK
                const { taskId, startX, startY, width, height, canvasWidth, canvasHeight } = e.data;
                const camPos = new Vec3(0, 3, -6), camTarget = new Vec3(0, 0, 0);
                const camForward = camTarget.sub(camPos).norm(), worldUp = new Vec3(0, 1, 0);
                const camRight = worldUp.cross(camForward).norm(), camUp = camForward.cross(camRight).norm();
                const pixelData = new Uint8ClampedArray(width * height * 4);
                // Heavy Mode: Reduced Samples to 8
                const SAMPLES = 8; 
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0;
                        for (let s = 0; s < SAMPLES; s++) {
                            let offX = Math.random(), offY = Math.random();
                            let u = ((startX + x + offX) / canvasWidth) * 2 - 1, v = -(((startY + y + offY) / canvasHeight) * 2 - 1);
                            u *= (canvasWidth / canvasHeight);
                            let rd = camForward.add(camRight.mul(u)).add(camUp.mul(v)).norm();
                            let col = trace(camPos, rd, 0);
                            r += col.x; g += col.y; b += col.z;
                        }
                        let idx = (y * width + x) * 4;
                        pixelData[idx] = Math.min(255, Math.floor((r / SAMPLES) * 255));
                        pixelData[idx + 1] = Math.min(255, Math.floor((g / SAMPLES) * 255));
                        pixelData[idx + 2] = Math.min(255, Math.floor((b / SAMPLES) * 255));
                        pixelData[idx + 3] = 255;
                    }
                }
                self.postMessage({ taskId, pixelData, startX, startY, width, height }, [pixelData.buffer]);
            }
        };
    </script>

    <!-- MAIN SCRIPT -->
    <script>
        // --- Configuration ---
        const CPU_RES_W = 1920; // Full HD
        const CPU_RES_H = 1080;
        const GPU_RES_W = 1920; 
        const GPU_RES_H = 1080;
        
        // --- Elements ---
        const startBtn = document.getElementById('start-btn');
        const statusText = document.getElementById('status-text');
        const coreCountDisplay = document.getElementById('core-count');
        const timeDisplay = document.getElementById('time-info');
        const resDisplay = document.getElementById('resolution-info');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const shareArea = document.getElementById('share-area');
        const copyBtn = document.getElementById('copy-btn');
        const cpuInput = document.getElementById('cpu-name-input');
        const modeSelect = document.getElementById('mode-select');
        const durationSelect = document.getElementById('duration-select');
        const bodyApp = document.getElementById('body-app');
        const scoreList = document.getElementById('score-list');

        let scoreDisplay;

        // --- State ---
        let currentMode = 'cpu'; 
        let isRunning = false;
        let finalScore = 0;
        let selectedDuration = 'default';
        let startTime = 0;
        
        // CPU State
        let workers = [];
        let taskQueue = [];
        let completedBlocks = 0;
        let totalBlocks = 0;
        let cpuFrames = 0;
        let cpuAnimationId; // Store RAF ID for cancelling
        let logicalProcessors = navigator.hardwareConcurrency || 4;

        // RAM State
        let ramTotalBytes = 0;
        let ramTotalTime = 0;
        let ramIterations = 0;
        let ramTimeoutId; // Store Timeout ID for cancelling
        const RAM_PASS_DEFAULT = 10; 

        // GPU State
        let gl;
        let gpuFrameCount = 0;
        let gpuAnimationId;
        const GPU_DUR_DEFAULT = 10000; 

        // Init UI
        coreCountDisplay.textContent = `${logicalProcessors} Threads`;

        // --- Mode Switching ---
        modeSelect.addEventListener('change', (e) => {
            if (isRunning) return;
            currentMode = e.target.value;
            updateUITheme();
        });

        durationSelect.addEventListener('change', (e) => {
            selectedDuration = e.target.value;
        });

        function updateUITheme() {
            createCanvasElement(); 
            shareArea.classList.add('hidden');
            bodyApp.className = "min-h-screen flex flex-col items-center justify-center p-3 sm:p-6 md:p-8"; // Reset
            
            if (currentMode === 'cpu') {
                statusText.textContent = "Ready (1080p / 8x AA / 140+ Objs)";
                resDisplay.textContent = "Scene: High Density Spheres | Res: 1920x1080";
                startBtn.textContent = "RUN CPU BENCHMARK";
                updateScores('cpu');
            } else if (currentMode === 'gpu') {
                bodyApp.classList.add('mode-gpu');
                statusText.textContent = "Ready (Mandelbox Fractal)";
                resDisplay.textContent = "Scene: 3D Fractal | Res: 1920x1080";
                startBtn.textContent = "RUN GPU BENCHMARK";
                updateScores('gpu');
            } else if (currentMode === 'ram') {
                bodyApp.classList.add('mode-ram');
                statusText.textContent = "Ready (Read/Write Bandwidth)";
                resDisplay.textContent = "Test: Multi-core Sequential Access";
                startBtn.textContent = "RUN RAM BENCHMARK";
                updateScores('ram');
                // Setup visualizer
                canvasWrapper.innerHTML = `<div class="ram-grid" id="ram-visualizer"></div>`;
                const grid = document.getElementById('ram-visualizer');
                for(let i=0; i<logicalProcessors; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'ram-cell rounded';
                    cell.id = `ram-cell-${i}`;
                    grid.appendChild(cell);
                }
            }
            scoreDisplay = document.getElementById('current-score');
        }

        function updateScores(mode) {
            let html = `
                <div class="flex justify-between items-center p-3 bg-purple-900/20 border border-purple-500/30 rounded-md">
                    <span class="text-purple-100 font-medium">Your System</span>
                    <span class="font-bold text-purple-400 text-lg sm:text-xl score-display" id="current-score">--</span>
                </div>`;

            if (mode === 'cpu') {
                html += `
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-200">Xeon W-2133</span><span class="text-[10px] sm:text-xs text-gray-500">6C/12T Workstation</span></div>
                        <span class="font-mono text-purple-200 text-base sm:text-lg">14317 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-200">iPad Air 3</span><span class="text-[10px] sm:text-xs text-gray-500">A12 Bionic (6C)</span></div>
                        <span class="font-mono text-purple-300 text-base sm:text-lg">9865 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-300">Celeron N4020</span><span class="text-[10px] sm:text-xs text-gray-500">2C/2T Entry</span></div>
                        <span class="font-mono text-gray-300 text-base sm:text-lg">2722 pts</span>
                    </div>`;
            } else if (mode === 'gpu') {
                html += `
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-300">Quadro P4000</span><span class="text-[10px] sm:text-xs text-gray-500">Pro Graphics</span></div>
                        <span class="font-mono text-blue-300 text-base sm:text-lg">21453 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-400">iPhone 15 Pro</span><span class="text-[10px] sm:text-xs text-gray-500">Mobile GPU</span></div>
                        <span class="font-mono text-gray-400 text-base sm:text-lg">~18000 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-400">iPad Air 3</span><span class="text-[10px] sm:text-xs text-gray-500">A12 Bionic GPU</span></div>
                        <span class="font-mono text-gray-400 text-base sm:text-lg">2760 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-gray-400">Intel HD 4200</span><span class="text-[10px] sm:text-xs text-gray-500">Old Integrated</span></div>
                        <span class="font-mono text-gray-400 text-base sm:text-lg">1047 pts</span>
                    </div>`;
            } else if (mode === 'ram') {
                html += `
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-green-200">Apple M1/M2/M3</span><span class="text-[10px] sm:text-xs text-gray-500">Unified Memory</span></div>
                        <span class="font-mono text-green-200 text-base sm:text-lg">~6000 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-green-300">DDR5-6000</span><span class="text-[10px] sm:text-xs text-gray-500">Dual Channel</span></div>
                        <span class="font-mono text-green-300 text-base sm:text-lg">~4500 pts</span>
                    </div>
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-md opacity-80">
                        <div class="flex flex-col"><span class="font-medium text-green-400">DDR4-3200</span><span class="text-[10px] sm:text-xs text-gray-500">Dual Channel</span></div>
                        <span class="font-mono text-green-400 text-base sm:text-lg">~2500 pts</span>
                    </div>`;
            }
            scoreList.innerHTML = html;
        }

        function createCanvasElement() {
            if (currentMode === 'ram') return; // Handled separately
            canvasWrapper.innerHTML = '';
            const c = document.createElement('canvas');
            c.id = 'render-canvas';
            if (currentMode === 'cpu') { c.width = CPU_RES_W; c.height = CPU_RES_H; }
            else { c.width = GPU_RES_W; c.height = GPU_RES_H; }
            canvasWrapper.appendChild(c);
            return c;
        }

        // --- Cancel Logic ---
        function cancelBenchmark() {
            isRunning = false;
            
            // Stop Loops
            cancelAnimationFrame(cpuAnimationId);
            cancelAnimationFrame(gpuAnimationId);
            clearTimeout(ramTimeoutId);

            // Kill Workers
            workers.forEach(w => w.worker.terminate());
            workers = [];

            // Reset UI
            startBtn.textContent = "RUN BENCHMARK";
            startBtn.classList.remove('btn-danger');
            startBtn.disabled = false;
            modeSelect.disabled = false;
            durationSelect.disabled = false;
            statusText.textContent = "Cancelled";
            scoreDisplay.textContent = "--";
            
            // Clear bucket visuals
            document.querySelectorAll('.bucket').forEach(el => el.remove());
            
            // Reset RAM visuals
            document.querySelectorAll('.ram-cell').forEach(c => c.classList.remove('active'));
        }

        // --- Main Runner ---
        startBtn.addEventListener('click', () => {
            if (isRunning) {
                cancelBenchmark();
                return;
            }
            
            isRunning = true;
            startBtn.textContent = "CANCEL";
            startBtn.classList.add('btn-danger');
            // Disabled is removed, we want to click it to cancel.
            // But we should disable inputs.
            modeSelect.disabled = true;
            durationSelect.disabled = true;
            
            shareArea.classList.add('hidden');
            scoreDisplay.textContent = "Running...";
            startTime = performance.now();
            
            if (currentMode === 'cpu') runCpuBenchmark();
            else if (currentMode === 'gpu') runGpuBenchmark();
            else if (currentMode === 'ram') runRamBenchmark();
        });

        // ==========================================
        // RAM BENCHMARK LOGIC
        // ==========================================
        function runRamBenchmark() {
            if(workers.length > 0) workers.forEach(w => w.worker.terminate());
            workers = [];
            const workerScript = document.getElementById('worker-code').textContent;
            const blob = new Blob([workerScript], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(blob);

            for (let i = 0; i < logicalProcessors; i++) {
                const w = new Worker(workerUrl);
                w.onmessage = handleRamMessage;
                workers.push({ id: i, worker: w, iterations: 0 });
            }

            ramTotalBytes = 0;
            ramTotalTime = 0; 
            ramIterations = 0;
            statusText.textContent = "Testing Memory Bandwidth...";
            
            startRamPass();
        }

        function startRamPass() {
            // Check condition
            const elapsedMs = performance.now() - startTime;
            let shouldStop = false;
            
            if (selectedDuration === 'default') {
                if (ramIterations >= RAM_PASS_DEFAULT) shouldStop = true;
            } else {
                if (elapsedMs >= parseInt(selectedDuration)) shouldStop = true;
            }

            if (shouldStop) {
                finishRamBenchmark();
                return;
            }

            ramIterations++;
            if (selectedDuration === 'default') {
                statusText.textContent = `Testing RAM... Pass ${ramIterations}/${RAM_PASS_DEFAULT}`;
            } else {
                statusText.textContent = `Testing RAM... ${(elapsedMs/1000).toFixed(0)}s elapsed`;
            }
            
            document.querySelectorAll('.ram-cell').forEach(c => c.classList.add('active'));

            const tStart = performance.now();
            let pending = workers.length;
            let batchBytes = 0;

            workers.forEach(w => {
                w.worker.postMessage({ taskType: 'ram', workerId: w.id });
                w.worker.onmessage = (e) => {
                    batchBytes += e.data.bytesProcessed;
                    pending--;
                    if(pending === 0) {
                        const tEnd = performance.now();
                        const dur = (tEnd - tStart) / 1000; 
                        ramTotalBytes += batchBytes;
                        ramTotalTime += dur;
                        
                        document.querySelectorAll('.ram-cell').forEach(c => c.classList.remove('active'));
                        ramTimeoutId = setTimeout(startRamPass, 50); 
                    }
                };
            });
        }

        function finishRamBenchmark() {
            isRunning = false;
            startBtn.textContent = "RUN AGAIN";
            startBtn.classList.remove('btn-danger');
            modeSelect.disabled = false;
            durationSelect.disabled = false;
            
            const avgBwBytes = ramTotalBytes / ramTotalTime; 
            const avgBwGB = avgBwBytes / (1024*1024*1024); 
            
            finalScore = Math.floor(avgBwGB * 60); 
            
            scoreDisplay.textContent = `${finalScore} pts`;
            statusText.textContent = `RAM Speed: ~${avgBwGB.toFixed(2)} GB/s`;
            shareArea.classList.remove('hidden');
        }

        function handleRamMessage(e) {}

        // ==========================================
        // CPU BENCHMARK LOGIC
        // ==========================================
        function runCpuBenchmark() {
            const canvas = document.getElementById('render-canvas');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CPU_RES_W, CPU_RES_H);

            workers.forEach(w => w.worker.terminate());
            workers = []; 
            
            const workerScript = document.getElementById('worker-code').textContent;
            const blob = new Blob([workerScript], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            
            document.querySelectorAll('.bucket').forEach(el => el.remove());

            for (let i = 0; i < logicalProcessors; i++) {
                const w = new Worker(workerUrl);
                const bucket = document.createElement('div');
                bucket.className = 'bucket';
                bucket.style.display = 'none';
                canvasWrapper.appendChild(bucket);
                
                w.onmessage = handleCpuMessage;
                workers.push({ id: i, worker: w, busy: false, bucketEl: bucket });
            }

            cpuFrames = 0;
            startCpuFrame();
            cpuAnimationId = requestAnimationFrame(updateCpuTimer);
        }

        function startCpuFrame() {
            // Clear canvas for each loop to show progress visually
            const canvas = document.getElementById('render-canvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CPU_RES_W, CPU_RES_H);

            taskQueue = [];
            let id = 0;
            const bs = 32;
            const cx = CPU_RES_W / 2, cy = CPU_RES_H / 2;
            for (let y = 0; y < CPU_RES_H; y += bs) {
                for (let x = 0; x < CPU_RES_W; x += bs) {
                    const w = Math.min(bs, CPU_RES_W - x);
                    const h = Math.min(bs, CPU_RES_H - y);
                    const distSq = (x + w/2 - cx)**2 + (y + h/2 - cy)**2;
                    taskQueue.push({ id: id++, x, y, w, h, distSq });
                }
            }
            taskQueue.sort((a, b) => a.distSq - b.distSq);
            totalBlocks = taskQueue.length;
            completedBlocks = 0;
            
            if (cpuFrames === 0) statusText.textContent = "Raytracing on CPU...";
            else statusText.textContent = `Looping... Pass ${cpuFrames + 1}`;

            workers.forEach(w => assignCpuTask(w));
        }

        function assignCpuTask(wObj) {
            if (taskQueue.length === 0) {
                if (workers.every(w => !w.busy)) finishCpuFrame();
                return;
            }
            const t = taskQueue.shift();
            wObj.busy = true;
            wObj.currentTask = t.id;
            
            const xPct = (t.x / CPU_RES_W) * 100;
            const yPct = (t.y / CPU_RES_H) * 100;
            const wPct = (t.w / CPU_RES_W) * 100;
            const hPct = (t.h / CPU_RES_H) * 100;
            wObj.bucketEl.style.left = `${xPct}%`;
            wObj.bucketEl.style.top = `${yPct}%`;
            wObj.bucketEl.style.width = `${wPct}%`;
            wObj.bucketEl.style.height = `${hPct}%`;
            wObj.bucketEl.style.display = 'block';

            wObj.worker.postMessage({
                taskId: t.id, startX: t.x, startY: t.y, width: t.w, height: t.h, canvasWidth: CPU_RES_W, canvasHeight: CPU_RES_H
            });
        }

        function handleCpuMessage(e) {
            const { taskId, pixelData, startX, startY, width, height } = e.data;
            const canvas = document.getElementById('render-canvas');
            const ctx = canvas.getContext('2d');
            const imgData = new ImageData(pixelData, width, height);
            ctx.putImageData(imgData, startX, startY);
            
            const wObj = workers.find(w => w.busy && w.currentTask === taskId);
            if (wObj) {
                wObj.busy = false;
                wObj.bucketEl.style.display = 'none';
                assignCpuTask(wObj);
            }
            completedBlocks++;
        }

        function updateCpuTimer() {
            if (!isRunning || currentMode !== 'cpu') return;
            const elapsed = (performance.now() - startTime) / 1000;
            timeDisplay.textContent = `Time: ${elapsed.toFixed(2)}s`;
            cpuAnimationId = requestAnimationFrame(updateCpuTimer);
        }

        function finishCpuFrame() {
            cpuFrames++;
            const elapsedMs = performance.now() - startTime;
            
            // Check if we should stop or loop
            let shouldStop = false;
            if (selectedDuration === 'default') {
                shouldStop = true; // One pass
            } else {
                if (elapsedMs >= parseInt(selectedDuration)) shouldStop = true;
            }

            if (shouldStop) {
                finishCpuBenchmarkAll();
            } else {
                // Loop
                startCpuFrame();
            }
        }

        function finishCpuBenchmarkAll() {
            isRunning = false;
            startBtn.textContent = "RUN AGAIN";
            startBtn.classList.remove('btn-danger');
            modeSelect.disabled = false;
            durationSelect.disabled = false;
            
            const dur = (performance.now() - startTime) / 1000;
            const pixels = CPU_RES_W * CPU_RES_H * cpuFrames;
            // Adjusted weight for "Heavy" mode
            const loadWeight = 120;
            const pps = pixels / dur;
            finalScore = Math.floor(pps / 10 * loadWeight / 100);
            
            scoreDisplay.textContent = `${finalScore} pts`;
            statusText.textContent = `CPU Benchmark Complete (${cpuFrames} loops)`;
            shareArea.classList.remove('hidden');
        }

        // ==========================================
        // GPU BENCHMARK LOGIC (WebGL)
        // ==========================================
        const fsSource = `
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;
            const int MAX_ITER = 64; 
            const float SCALE = 2.8;
            float map(vec3 p) {
                vec3 z = p; float dr = 1.0;
                for (int i=0; i<12; i++) {
                    if (z.x > 1.0) z.x = 2.0 - z.x; else if (z.x < -1.0) z.x = -2.0 - z.x;
                    if (z.y > 1.0) z.y = 2.0 - z.y; else if (z.y < -1.0) z.y = -2.0 - z.y;
                    if (z.z > 1.0) z.z = 2.0 - z.z; else if (z.z < -1.0) z.z = -2.0 - z.z;
                    float r2 = dot(z,z);
                    if (r2 < 0.25) { z *= 4.0; dr *= 4.0; } else if (r2 < 1.0) { z /= r2; dr /= r2; }
                    z = z * SCALE + p; dr = dr * abs(SCALE) + 1.0;
                }
                return (length(z) - 0.0) / abs(dr);
            }
            vec3 getNormal(vec3 p) {
                float d = map(p); vec2 e = vec2(0.001, 0.0);
                return normalize(vec3(d - map(p - e.xyy), d - map(p - e.yxy), d - map(p - e.yyx)));
            }
            void main() {
                vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);
                float t = u_time * 0.2;
                vec3 ro = vec3(3.5 * sin(t), 3.0 * cos(t*0.7), 3.5 * cos(t));
                vec3 ta = vec3(0.0);
                vec3 fwd = normalize(ta - ro); vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0))); vec3 up = cross(right, fwd);
                vec3 rd = normalize(fwd + right * uv.x + up * uv.y);
                float dist = 0.0; float t_march = 0.0; vec3 p; int steps = 0;
                for (int i=0; i<MAX_ITER; i++) {
                    p = ro + rd * t_march; dist = map(p);
                    if (dist < 0.001 || t_march > 20.0) break;
                    t_march += dist; steps = i;
                }
                vec3 color = vec3(0.0);
                if (t_march < 20.0) {
                    vec3 n = getNormal(p); vec3 light = normalize(vec3(1.0, 2.0, -1.0));
                    float diff = max(dot(n, light), 0.0);
                    float glow = float(steps) / float(MAX_ITER);
                    color = vec3(0.1, 0.5, 1.0) * diff; color += vec3(1.0, 0.4, 0.2) * glow * 1.5;
                } else { color = vec3(0.05, 0.05, 0.1); }
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        const vsSource = `attribute vec4 aVertexPosition; void main() { gl_Position = aVertexPosition; }`;

        function runGpuBenchmark() {
            const canvas = document.getElementById('render-canvas');
            gl = canvas.getContext('webgl');
            if (!gl) { alert('WebGL not supported'); isRunning = false; startBtn.disabled = false; modeSelect.disabled = false; durationSelect.disabled = false; return; }
            const vs = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(program)); return; }
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0]), gl.STATIC_DRAW);
            const vertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
            gl.enableVertexAttribArray(vertexPosition);
            gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.useProgram(program);
            const uRes = gl.getUniformLocation(program, 'u_resolution');
            const uTime = gl.getUniformLocation(program, 'u_time');
            gl.uniform2f(uRes, canvas.width, canvas.height);
            
            gpuStartTime = performance.now();
            gpuFrameCount = 0;
            
            let durText = selectedDuration === 'default' ? "10s" : `${parseInt(selectedDuration)/1000}s`;
            statusText.textContent = `Stressing GPU (${durText})...`;
            
            function render(now) {
                if (!isRunning) return;
                
                const elapsed = now - gpuStartTime;
                timeDisplay.textContent = `Time: ${(elapsed/1000).toFixed(2)}s`;
                
                let targetTime = selectedDuration === 'default' ? GPU_DUR_DEFAULT : parseInt(selectedDuration);

                if (elapsed > targetTime) { finishGpuBenchmark(elapsed); return; }
                
                gl.uniform1f(uTime, elapsed / 1000.0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gpuFrameCount++;
                gpuAnimationId = requestAnimationFrame(render);
            }
            gpuAnimationId = requestAnimationFrame(render);
        }
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; }
            return shader;
        }
        function finishGpuBenchmark(durationMs) {
            isRunning = false; 
            startBtn.textContent = "RUN AGAIN";
            startBtn.classList.remove('btn-danger');
            modeSelect.disabled = false; durationSelect.disabled = false;
            const durationSec = durationMs / 1000;
            const avgFps = gpuFrameCount / durationSec;
            finalScore = Math.floor(avgFps * 350); 
            scoreDisplay.textContent = `${finalScore} pts`;
            statusText.textContent = `GPU Finished: Avg ${Math.floor(avgFps)} FPS`;
            shareArea.classList.remove('hidden');
        }

        // --- Copy Func ---
        copyBtn.addEventListener('click', () => {
            const cpuName = cpuInput.value || "Unknown Device";
            let modeName = '';
            if (currentMode === 'cpu') modeName = 'CPU (Heavy)';
            else if (currentMode === 'gpu') modeName = 'GPU (Mandelbox)';
            else modeName = 'RAM (Bandwidth)';
            
            // Add duration info to copy
            let durLabel = "Standard";
            if (selectedDuration === '60000') durLabel = "1min";
            if (selectedDuration === '180000') durLabel = "3min";
            if (selectedDuration === '300000') durLabel = "5min";
            if (selectedDuration === '600000') durLabel = "10min";

            const text = `WebBench Score: ${finalScore} pts [${modeName}] (${durLabel}) - ${cpuName}`;
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try { document.execCommand('copy'); 
                const orig = copyBtn.textContent; copyBtn.textContent = "Copied!"; setTimeout(()=>copyBtn.textContent=orig, 2000);
            } catch (e) {}
            document.body.removeChild(textArea);
        });

        updateUITheme(); // Init
    </script>
</body>
</html>